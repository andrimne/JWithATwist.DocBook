<?xml version="1.0" encoding="UTF-8"?>
<article xml:lang="en" xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xl="http://www.w3.org/1999/xlink">
	<info>		
		<title>JWithATwist Reference Manual</title>
		        <legalnotice>
            <simpara>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="resources/CC88x31BY.png"/>
                    </imageobject>
                </inlinemediaobject>
                This work is licensed under the Creative Commons Attribution 4.0 International License. To view a copy of this license, visit <link xl:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</link>.
            </simpara>
        </legalnotice>
		<copyright>
        <year>2016</year>
        <holder>CC: By Erling Hellen√§s</holder>
 </copyright>
	</info>
	<section>
		<title>JWithATwist</title>
		<para>JWithATwist is a programming language under development. It has many similarities with J. You can find descriptions of J at <link xl:href="www.jsoftware.com">www.jsoftware.com</link>.</para>
		<para>I use a J-like syntax to describe this language. The terms can have slightly different definitions because of language differences.</para>
		<para>The most important language concepts are:</para>
<itemizedlist>
	<listitem>
		<para><glossterm>Noun</glossterm> - an n-dimensional array of values where the values are simple data types or other n-dimensional arrays.</para>
	</listitem>
	<listitem>
	<para><glossterm>Verb</glossterm> - a function with one or two noun arguments returning a noun.</para>
</listitem>
	<listitem>
	<para><glossterm>Adverb</glossterm> - a function with a verb argument and one or two noun arguments, returning a noun.</para>
</listitem>
	<listitem>
	<para><glossterm>Conjunction</glossterm> - an operator with two verb arguments and one or two noun arguments, returning a noun.</para>
</listitem>
</itemizedlist>
<para>A <glossterm>monadic</glossterm> verb has one argument, a <glossterm>dyadic</glossterm> verb has two. Adverbs and conjunctions are also called monadic or dyadic after their number of noun arguments.</para>
<para>Nouns, verbs, adverbs and conjunctions all have their own sections in this manual. A section describes the language syntax. The last section describes the use cases.</para>
	</section>
	<section>
	<title>The JWithATwist Noun</title>
	<para>The noun is n-dimensional array. It has one of these data types: </para>
	<itemizedlist>
	<listitem>
		<para>Integer</para>
	</listitem>
	<listitem>
		<para>Float</para>
	</listitem>	
	<listitem>
		<para>Boolean</para>
	</listitem>		
	<listitem>
		<para>Unicode</para>
	</listitem>		
	<listitem>
		<para>Boxed</para>
	</listitem>		
	</itemizedlist>	
	<para>Integer, Float, Boolean and Unicode corresponds to the .NET data types of Int64, Double, Bool and Char, Unicode-16.</para>	
	<para>A noun of data type <glossterm>boxed</glossterm> contains other n-dimensional arrays, which can also be boxed.</para>
	<para>The <glossterm>rank</glossterm> of a noun is the number of dimensions of the array it contains.</para>
	<para>The nouns are immutable. The value is defined when it is created. It can not be changed. Modification operations return a new noun. </para>
	<para> A noun with zero dimensions, a singleton, is called a <glossterm>scalar</glossterm>.</para>
	<para>The noun is seen as a structure of something called <glossterm>k-cells</glossterm>. The scalar is a 0-cell, the vector a 1-cell, the table a 2-cell and so on for higher dimensions. An n-cell contains a number of (n-1)-cells which contains a number of (n-2)-cells.</para>
	<para>A 0-cell can also be called a <glossterm>cell</glossterm>.</para><section>
	<title>Literals</title>
	<para>Simple data types are entered in the following ways:</para>
		<itemizedlist>
	<listitem>
		<para>Integer: <code>0 -1 2 3</code></para>
	</listitem>
	<listitem>
		<para>Float: <code>0.0 -1.0e4 nan infinity -infinity</code></para>
	</listitem>	
	<listitem>
		<para>Boolean: <code>true false</code></para>
	</listitem>		
	<listitem>
		<para>Unicode: <code>"John" "George"</code></para>
	</listitem>		
	</itemizedlist>	
	<para>If you enter only one value the result is a scalar, a 0-cell. If you enter more than one value the result is a vector. </para>
	<para>When you enter unicode values the result is a boxed noun of unicode nouns. A boxed array of unicode arrays. </para>
</section>
</section>
<section>
	<title>The JWithATwist Verbs</title>
	<para>The JWithATwist verbs are normally array operations. The arguments are one or two arrays, the result another array. You write <code>1 5 + 2 3</code> and get the result <code>3 8</code>.</para>
	<para>We talk about the <glossterm>rank</glossterm> of a verb. The rank is the k-cell or k-cells of the argument or arguments that the actual underlying operation is performed on. A scalar operation is done on one or two 0-cell arguments. We say that a monadic scalar verb has rank 0 because the underlying operation is performed on one 0-cell argument. We say that a dyadic scalar verb has rank 0 0 because the underlying operation is done between two 0-cell arguments. The arguments of the verb are arrays, but the underlying operation has a 0-cell argument or two 0-cell arguments.</para>
	<para>To show that a verb operates on the whole of an argument, we denote the rank with _ . A monadic verb operating on the whole of its argument has rank _ . A dyadic verb operating on the whole of its both arguments has rank _ _. JWithATwist does not allow you to write this in the program, but you can use the actual rank of the argument or any higher number.</para>
	<para>Most verbs are scalar, which means that the underlying operation is done between corresponding cells of the argument arrays. The result of the underlying operation is another cell. The array part of the operation is handled in the same way for all of these verbs. The verbs use a helper program to handle the loop over the parts of the arguments the verb does not handle.</para>		
	<para>Other verbs have other ranks. The underlying operation can be performed on part or whole of the array arguments. If the underlying operation is not done on the whole of the arguments, the verbs use a helper program to handle the loop over the parts of the arguments the verb itself does not handle.</para>
	<para>There are four such helper programs, one for monadic and one for dyadic scalar operations, one for monadic and one for dyadic array operations. </para>
	<para>To understand JWithATwist it is important to understand these helper programs.</para>
	<section>
	<title>The Monadic Scalar Operation Helper Program</title>
	<para>The monadic scalar operation helper program performs the underlying operation on each cell of the argument. The result is an array of the same size. This operation is usually called <emphasis>map</emphasis> in functional languages.</para>
	<para>The monadic scalar operation helper program also handles type conversions from integer to float. If a float operation is performed on an integer it is automatically converted to a float before the operation. </para>
</section>
<section>
	<title>The Dyadic Scalar Operation Helper Program</title>
	<para>The basic function of the dyadic scalar operation helper program is to perform the underlying operation between the corresponding cells of the argument arrays. The result is an array of the same size. This operation is usually called <emphasis>map2</emphasis> in functional languages. </para>
	<para>If one of the arguments is a scalar, the operation is performed between this scalar and each of the cells of the other argument.</para>	
	<para>If the arguments have different shape, but the shape of one of the arguments is the same as the shape of the first part of the other argument, a loop is created over the remaining part of the larger argument. We talk about <glossterm>agreement</glossterm>. Agreement is how JWithATwist handles operations between arguments of different shape and rank. Which combinations are allowed and which combinations are not.</para>	
<literallayout>Example:
<code>
    10 20 + |i. 2 3
10 11 12
20 21 22
</code></literallayout>
<para>The shape of the left argument in the example is 2, the same as the first part of the shape 2 3 of the right argument. The helper program creates a loop over the remaining part, the cells in the rows, and the corresponding part of the left argument is added to each of these cells.</para>
	<para>The dyadic scalar operation helper program also handles type conversions from integer to float. If a float operation is performed on an integer it is automatically converted to a float before the operation. </para>
</section><section>
	<title>The Monadic Array Operation Helper Program</title>
	<para>The monadic array operation helper program is available to the user as the monadic rank adverb.</para>
	<para>If a monadic verb is not scalar, if the underlying operation does not handle the whole of it's array argument and if the argument is correct, it calls the monadic array operation helper program to loop over the parts of the argument it does not handle.</para>
	<para>As an example, the monadic Iota verb is an index generator. It generates an n-dimensional array of indexes when given a vector argument. <code>|i. 3</code> gives a result of <code>0 1 2</code>. <code>|i. 2 3</code> gives a shape 2 3 array with rows <code>0 1 2</code> and <code>3 4 5</code> as result.  If given an argument of rank higher than 1, it calls the monadic array operation helper program to handle the loop over the rank 1 parts it handles.</para>
	<para>The Iota verb is then called a number of times by the monadic array operation helper program, which the Iota verb itself called as a helper program. Each time the Iota verb is called with a vector argument. The result is a number of n-dimensional arrays with different shape but with the same rank, since the 1-cells of the argument all have the same length. The monadic array operation helper program calculates the maximum shape of the result in each dimension. It pads all the results so that they all have this same maximum shape. The shape of the result is the shape of the part of the argument shape the Iota verb does not handle catenated with the maximum shape of the Iota verb results. </para>
<literallayout>Example:
<code>
    2 2 $ 2 1 1 3
2 1
1 3
    |i. 2 2 $ 2 1 1 3
Type: Integer, Shape: 2 2 3 , Values: 0 0 0 1 0 0 0 1 2 0 0 0 ...
    |$ |i. 2 2 $ 2 1 1 3
2 2 3
    |i. 2 1
0
1
    |i. 1 3
0 1 2
</code></literallayout>
<para>The Iota verb handles each row of the argument and calls the monadic array operation helper program to loop over the two rows. Like this: <code>    |i. '/ 1 / 2 2 $ 2 1 1 3</code>.</para>
<para>The results from each call to the Iota verb from the monadic array operation helper program is the column <code>0 1</code> and the row <code>0 1 2</code>.</para> <para>These results are padded to the shape 2 3. The final result has the shape of <code>2 2 3</code>, the part of the argument shape not handled by the Iota verb, <code>2</code>, catenated with <code>2 3</code>, the maximum shape of the Iota verb results. </para>
</section>
<section>
	<title>The Dyadic Array Operation Helper Program</title>
		<para>The dyadic array operation helper program is available to the user as the dyadic rank adverb.</para>
<para>If a dyadic verb is not scalar, if the underlying operation does not handle the whole of both of it's array arguments and if the arguments are correct, it calls the dyadic array operation helper program to loop over the parts of the argument it does not handle.</para>
<para>As an example, the Shape verb shapes the whole of the right argument to the shape described by it's vector left argument. <code>2 2 2 $ 0 1 2 3 4 5 6 7</code> creates a three-dimensional array with the shape <code>2 2 2</code>. If given a left argument of rank higher than 1, the Shape verb calls the the dyadic array operation helper program to handle the loop over the rank 1 parts of the left argument it handles.</para> 
	<para>The Shape verb is then called a number of times by the dyadic array operation helper program, which the Shape verb itself called as a helper program. Each time the Shape verb is called with a vector left argument. The result is a number of n-dimensional arrays with different shape but with the same rank, since the 1-cells of the left argument all have the same length. The dyadic array operation helper program calculates the maximum shape of the result in each dimension. It pads all the results so that they all have this same maximum shape. The shape of the result is the shape of the part of the left argument shape the Shape verb does not handle catenated with the maximum shape of the Shape verb results. </para>
<literallayout>Example:
<code>
    2 2 $ 2 1 1 3
2 1
1 3
    ( 2 2 $ 2 1 1 3 ) $ |i. 3
Type: Integer, Shape: 2 2 3 , Values: 0 0 0 1 0 0 0 1 2 0 0 0 ...
    |$ ( 2 2 $ 2 1 1 3 )
2 2 3
    ( 2 1 ) $ |i. 3
0
1
    ( 1 3 ) $ |i. 3
0 1 2
</code></literallayout>
<para>The Shape verb handles each row of the left argument and calls the dyadic array operation helper program to loop over the two rows. Like this: <code>( 2 2 $ 2 1 1 3 ) $ '/ 1 2 / |i. 3 </code>.</para>
<para>The results from each call to the Shape verb from the dyadic array operation helper program is the column <code>0 1</code> and the row <code>0 1 2</code>.</para> <para>These results are padded to the shape 2 3. The final result has the shape of <code>2 2 3</code>, the part of the argument shape not handled by the Shape verb, <code>2</code>, catenated with <code>2 3</code>, the maximum shape of the Shape verb results. </para>
</section>
<section>
	<title>Monadic Scalar Verbs</title>
	<para>The monadic scalar verbs are described in table XX, YY, ..</para>
		<table>
	<title>Arithmetic Monadic Scalar Verbs</title>
	<tgroup cols="2">
		<tbody>
			<row>
				<entry><code>|*</code></entry>
				<entry>Signum</entry>
			</row>
			<row>
				<entry><code>|%</code></entry>
				<entry>Reciprocal</entry>
			</row>	
			<row>
				<entry><code>|&lt;.</code></entry>
				<entry>Floor</entry>
			</row>
			<row>
				<entry><code>|&gt;.</code></entry>
				<entry>Ceiling</entry>
			</row>	
						<row>
				<entry><code>|-</code></entry>
				<entry>Negate</entry>
			</row>
								<row>
				<entry><code>||</code></entry>
				<entry>Magnitude</entry>
			</row>
		</tbody>
	</tgroup>
</table>
<para>Floor and Ceiling are float operations. In JWithATwist the result in an integer. The largest integer a float can correctly represent is 2 raised to the power of 51. The smallest integer a float can correctly represent is the negation of this. In JWithATwist, if Floor and Ceiling is used on a float with larger absolute value the result is domain error.</para>
		<table>
	<title>Boolean Monadic Scalar Verbs</title>
	<tgroup cols="2">
		<tbody>
			<row>
				<entry><code>|-.</code></entry>
				<entry>Not</entry>
			</row>
		</tbody>
	</tgroup>
</table>
		<table>
	<title>Conversion Monadic Scalar Verbs</title>
	<tgroup cols="2">
		<tbody>
			<row>
				<entry><code>|_</code></entry>
				<entry>Boolean to integer</entry>
			</row>
		</tbody>
	</tgroup>
</table>
</section>
<section>
	<title>Dyadic Scalar Verbs</title>
	<para>The dyadic scalar verbs are described in table XX, YY, ..</para>
	<table>
	<title>Arithmetic Dyadic Scalar Verbs</title>
	<tgroup cols="2">
		<tbody>
			<row>
				<entry><code>+</code></entry>
				<entry>Add</entry>
			</row>
			<row>
				<entry><code>-</code></entry>
				<entry>Subtract</entry>
			</row>	
			<row>
				<entry><code>*</code></entry>
				<entry>Times</entry>
			</row>
			<row>
				<entry><code>%</code></entry>
				<entry>Divide</entry>
			</row>	
			<row>
				<entry><code>&lt;.</code></entry>
				<entry>Min</entry>
			</row>			
			<row>
				<entry><code>&gt;.</code></entry>
				<entry>Max</entry>
			</row>
			<row>
				<entry><code>^</code></entry>
				<entry>Power</entry>
			</row>			
		</tbody>
	</tgroup>
</table>
<para>In JWithATwist Power always returns a float.</para>
	<table>
	<title>Comparison Dyadic Scalar Verbs</title>
	<tgroup cols="2">
		<tbody>
			<row>
				<entry><code>&lt;</code></entry>
				<entry>Less than</entry>
			</row>
			<row>
				<entry><code>&lt;:</code></entry>
				<entry>Less than or equal</entry>
			</row>			
			<row>
				<entry><code>&gt;</code></entry>
				<entry>Greater than</entry>
			</row>	
			<row>
				<entry><code>&gt;:</code></entry>
				<entry>Greater than or equal</entry>
			</row>	
			<row>
				<entry><code>=</code></entry>
				<entry>Equal</entry>
			</row>	
			<row>
				<entry><code>~:</code></entry>
				<entry>Not equal</entry>
			</row>	
		</tbody>
	</tgroup>
</table>
<para>JWithATwist does not use comparison tolerance. The use of equality operations on floats is not recommended.</para>
	<table>
	<title>Boolean Dyadic Scalar Verbs</title>
	<tgroup cols="2">
		<tbody>
			<row>
				<entry><code>*.</code></entry>
				<entry>And</entry>
			</row>
			<row>
				<entry><code>+.</code></entry>
				<entry>Or</entry>
			</row>	
		</tbody>
	</tgroup>
</table>
</section>
<section>
	<title>Non-Scalar Monadic Verbs</title>
	<para>The non-scalar monadic verbs are shown in table XXX</para>
	<table>
	<title>Non-Scalar Monadic Verbs</title>
	<tgroup cols="2">
		<tbody>
			<row>
				<entry><code>|&lt;</code></entry>
				<entry>Box</entry>
			</row>	
			<row>
				<entry><code>|':</code></entry>
				<entry>DefaultFormat</entry>
			</row>				
			<row>
				<entry><code>|/:</code></entry>
				<entry>GradeUp</entry>
			</row>	
							<row>
				<entry><code>|i.</code></entry>
				<entry>Monadic Iota</entry>
			</row>			
							<row>
				<entry><code>|&gt;</code></entry>
				<entry>Open</entry>
			</row>
			<row>
				<entry><code>|$</code></entry>
				<entry>ShapeOf</entry>
			</row>	
			<row>
			<entry><code>|#</code></entry>
				<entry>Tally</entry>
			</row>	

		</tbody>
	</tgroup>
</table>	
<section>
	<title>The Box Monadic Verb</title>
	<para>The Box monadic verb is a verb of rank _ . It is applied to the whole of the right argument. There is no underlying verb. The Box verb creates a boxed scalar noun containing its right argument. The box verb can be used together with the monadic Rank adverb to box k-cells of the argument. It can be used in verb definition arguments to adverbs and conjunctions to box the results. If the verb definition argument to an adverb creates results of different shapes, you might have to box the results. You normally have to open boxed nouns with Open before you can operate on them. After doing your operation you can box the results. </para>
<literallayout>Examples:
<code>
    |&lt; 1 2 3
 1 2 3
	|$ |&lt; 1 2 3

    |&lt; '/ 0 / 1 2 3
 1 2 3    
    |$ |&lt; '/ 0 / 1 2 3
 3
    "" {! |&lt; ( |&gt; [ ) , |&gt; ] } / "John " "Lennon"
John Lennon
    |$ |> "" {! |&lt; ( |&gt; [ ) , |&gt; ] } / "John " "Lennon"
 11
    "John " "Lennon"
John Lennon
	|$ "John " "Lennon"
 2
</code></literallayout>
</section>
<section>
	<title>The DeaultFormat Monadic Verb</title>
	<para>The DefaultFormat monadic verb is a verb of rank _ . It is applied to the whole of the right argument. There is no underlying verb. The DefaultFormat verb is also used to format the output in the JWithATwist terminal.</para>
	<para>DefaultFormat formats data of rank less than 2 in a simple way. If given data of higher rank the output shows data type, shape and up to 20 values of the output. </para>
	<para>Numeric and boolean data is first converted to boxed arrays. Each cell is formatted to a Unicode array and is then boxed.</para>	
	<para>DefaultFormat recursively formats data in boxed arrays. All data is top right adjusted in the area corresponding to the box.</para>
	<para>The size of the boxes in the output is determined by the maximum number of rows of content in the boxes on the same row of boxes and the maximum number of cell columns of content in the boxes in the same column of boxes.  </para>
<literallayout>Examples:
<code>
    |': 1 2 3
 1 2 3
    |': -1.2345678e-300 1
 -1.23457e-300 1
    |': true false
 true false
    |': "JWithATwist is cool!"
JWithATwist is cool!
    |': ( "Column 1" " Column 2" ) , |&lt; |'/ 0 / |i. 2 2 
Column 1 Column 2
       0        1
       2        3 
    |i. 2 2 2
Type: Integer, Shape: 2 2 2 , Values: 0 1 2 3 4 5 6 7 ...
</code></literallayout>
</section>
<section>
	<title>The GradeUp Monadic Verb</title>
	<para>The GradeUp monadic verb is a verb of rank _ . It is applied to the whole of the right argument. There is no underlying verb.</para>
	<para>The result of GradeUp is an index which can be used together with From to sort the right argument in ascending order.</para>
	<para>If you apply GradeUp to the produced index you get a new index which can be used to sort the right argument back to its original order.</para>
	<para> This sort back functionality is frequently used in languages like JWithATwist. You sort information, process it in sorted order and sort the results back to the original order.</para>
		<para>GradeUp can be used on 1 and 2-dimensional arrays. It can not be used on arrays of higher rank.</para>
		<para>GradeUp sorts Unicode in a sort order determined by region settings in Windows. Upper and lower case values are considered equal.</para>			
		<para>GradeUp can not be used on boxed arrays.</para>
		<para>GradeUp is a stable sort. It does not reorder elements which are equal. </para>
<literallayout>Examples:
<code>
    |/: 3 1 2
 1 2 0
    1 2 0 &lt;- 3 1 2
 1 2 3
    |/: 1 2 0
 2 0 1
    2 0 1 &lt;- 1 2 3
 3 1 2
</code></literallayout>
</section>
<section>
	<title>The Monadic Iota Verb</title>
	<para>The monadic Iota verb is a verb of rank 1 . It is applied to a scalar or vector right argument. When applied to a right argument of higher rank, it calls the monadic array operation helper program to loop over the parts of the argument it does not handle.</para>
	<para>Monadic Iota is an index generator.</para>
	<para>The result of monadic Iota is a sequence of natural numbers starting at 0.</para>
	<para>With a scalar right argument the result is a vector of consecutive natural numbers. The length of the vector of natural numbers is the absolute value of the right argument. If the right argument is positive this vector is sorted in ascending order. If the right argument is negative the vector is sorted in descending order.</para>
		<para>With a vector right argument the result is an array of natural numbers. The rank of the resulting array is the same as the length of the vector right argument. The shape of the resulting array is the same as the absolute value of the vector right argument. The resulting array contains all consecutive natural numbers from 0 to one less than the number of cells in the result array. If a cell in the vector right argument is positive the natural numbers along the corresponding dimension are sorted in ascending order. If a cell in the vector right argument is negative the natural numbers along the corresponding dimension are sorted in descending order. </para>
<para>Monadic Iota is used for indexing and sorting. One application is reversal of the sort order of dimensions in an array.</para>
<literallayout>Examples:
<code>
    |i. 3 
 0 1 2
    |i. -3
 2 1 0
    |i. 2 2
 0 1
 2 3
    |i. -2 -2
 3 2
 1 0
    2 2 $ 3 4 5 6
 3 4
 5 6
    ( |i. 2 -2 ) &lt;- |, 2 2 $ 3 4 5 6
 4 3
 6 5
</code></literallayout>
</section>
<section>
	<title>The Open Monadic Verb</title>
	<para>The Open monadic verb is a verb of rank 0. It is applied to the cells of the right argument. If the argument contains more than one cell, the monadic array operation helper program is used as a helper function.</para> 
	<para> The Open verb removes one layer of boxing of its right argument. It there are several layers of boxing, the result is still boxed. If not, the result is a noun of one of the non-boxed data types, the noun content of the boxed right argument. </para>
	<para>If you open a noun which is not boxed the result is the same noun.</para>
	<para>Open can be used in verb definition arguments to adverbs and conjunctions to open boxed arguments. You normally have to open boxed nouns with Open before you can operate on them. After doing your operation you can box the results. </para>
	<literallayout>Examples:
<code>
    |&gt; |&lt; 1 2 3
 1 2 3
    |&gt; ( |&lt; 2 1 $ 0 1 ) , |&lt; 1 3 $ 0 1 2
Type: Integer, Shape: 2 2 3 , Values: 0 0 0 1 0 0 0 1 2 0 0 0 ...
    |&gt; '/ 0 / ( |&lt; 2 1 $ 0 1 ) , |&lt; 1 3 $ 0 1 2
Type: Integer, Shape: 2 2 3 , Values: 0 0 0 1 0 0 0 1 2 0 0 0 ...
    |&gt; |&lt; |&lt; 1 2 3
 1 2 3
    |$ |&gt; |&lt; |&lt; 1 2 3 

    |&gt; 1 2 3
 1 2 3
    |$ |&gt; 1 2 3 
 3    
    "" {! |&lt; ( |&gt; [ ) , |&gt; ] } / "John " "Lennon"
John Lennon
</code></literallayout>
</section>
<section>
	<title>The ShapeOf Monadic Verb</title>
	<para>The ShapeOf monadic verb is a verb of rank _ . It is applied to the whole of the right argument. There is no underlying verb.</para>
	<para>ShapeOf returns the shape of the right argument.</para>
<literallayout>Examples:
<code>
    |i. 2 3
 0 1 2
 3 4 5
    |$ |i. 2 3
 2 3
</code></literallayout>
</section>
<section>
	<title>The Tally Monadic Verb</title>
	<para>The Tally monadic verb is a verb of rank _ . It is applied to the whole of the right argument. There is no underlying verb.</para>
	<para>Tally returns the size of the right argument in its first dimension.</para>
<literallayout>Examples:
<code>
    |i. 2 3
 0 1 2
 3 4 5
    |# |i. 2 3
 2
</code></literallayout>
</section>
</section>

<section>
	<title>Non-Scalar Dyadic Verbs</title>
	<para>The non-scalar dyadic verbs are shown in table XXX</para>
	<table>
	<title>Non-Scalar Dyadic Verbs</title>
	<tgroup cols="2">
		<tbody>
			<row>
				<entry><code>&gt;-</code></entry>
				<entry>Amend</entry>
			</row>	
			<row>
				<entry><code>&gt;.-</code></entry>
				<entry>Drop</entry>
			</row>	
			<row>
				<entry><code>&lt;-</code></entry>
				<entry>From</entry>
			</row>
			<row>
				<entry><code>i.</code></entry>
				<entry>Dyadic Iota</entry>
			</row>				
			<row>
				<entry><code>#</code></entry>
				<entry>Replicate</entry>
			</row>				
			<row>
				<entry><code>/::</code></entry>
				<entry>Select</entry>
			</row>			
			<row>
				<entry><code>$</code></entry>
				<entry>Shape</entry>
			</row>		
			<row>
				<entry><code>&lt;.-</code></entry>
				<entry>Take</entry>
			</row>
			<row>
			<entry><code>\::</code></entry>
				<entry>Transpose</entry>
			</row>				
		</tbody>
	</tgroup>
</table>	

<section>
	<title>The Amend Dyadic Verb</title>
	<para>The Amend dyadic verb is a verb of rank _ _ . It is applied to the whole of the right and left argument. There is no underlying verb.</para>
	<para>Amend is used to replace k-cells of the right argument. The result is a new noun where the k-cells are replaced. The original noun is not modified.</para>
	<para>The left argument is a boxed array with two values. The first box contains indexes along the first dimension of the right argument. The second box contains the k-cells with which the present contents at these indexes should be replaced.</para>
<literallayout>Example:
<code>
    ( ( |&lt; 1 2 ) , |&lt; -4 -5 ) &gt;- 0 1 2 3 4
 0 -4 -5 3 4
</code></literallayout>
</section>
<section>
	<title>The Drop Dyadic Verb</title>
	<para>The Drop dyadic verb is a verb of rank _ _ . It is applied to the whole of the right and left argument. There is no underlying verb.</para>
	<para>Drop is used to remove k-cells of the right argument. The result is a new noun where these k-cells are removed. The original noun is not modified.</para>
	<para>If the left argument is a positive scalar, it denotes the number of k-cells that should be removed from the head of the right argument.</para>
	<para>If the left argument is a negative scalar, it denotes the number of k-cells that should be removed from the tail of the right argument.</para>	
	<para>If the left argument is a vector of length n, it denotes the number of k-cells that should be removed from the head or tail of the first n dimensions of the right argument.</para>
	<para>If the number of k-cells to remove is larger than the array length in the corresponding dimension, all k-cells in this dimension are removed.</para>
<literallayout>Example:
<code>
    2 &gt;.- 0 1 2 3
 2 3
    -2 &gt;.- 0 1 2 3
 0 1
    1 1 &gt;.- |i. 2 2 2
 6 7
</code></literallayout>
</section>
<section>
	<title>The From Dyadic Verb</title>
	<para>The From dyadic verb is a verb of rank _ _ . It is applied to the whole of the right and left argument. There is no underlying verb.</para>
	<para>From is used to select k-cells of the right argument. The result is a new noun with the selected k-cells. The original noun is not modified.</para>
	<para>The left argument contains indexes along the first dimension of the right argument.</para>
		<para>From can be used together with the dyadic Rank operator to select k-cells along other dimensions than the first dimension.</para>
<literallayout>Example:
<code>
    1 2 &lt;- 1 2 3 4
 2 3
    1 2 &lt;- '/ 1 1 / |i. 2 4
 1 2
 5 6    
</code></literallayout>
</section>
<section>
	<title>The Dyadic Iota Verb</title>
	<para>The dyadic Iota verb is a verb of rank _ _ . It is applied to the whole of the right and left argument. If the left argument is not a scalar, vector or table the result is rank error. There is no underlying verb. It does not handle boxed data.</para>
	<para>The dyadic Iota verb searches in the k-cells of the left argument for corresponding k-cells in the right argument. If the k-cell of the right argument is found in the k-cells of the left argument the corresponding cell in the result contains the index of the first k-cell in the left argument equal to the right argument k-cell. If the k-cell of the right argument is not found in the k-cells of the left argument the corresponding cell in the result contains the length of the left argument.</para>
<literallayout>Example:
<code>
    1 2 3 i. 2
 1
    1 2 3 i. 0
 3
    1 2 3 i. |i. 2 2
 3 0
 1 2
    ( |i. 2 2 ) i. |i. -4 2
 2 2 1 0 
</code></literallayout>
</section>
<section>
	<title>The Replicate Dyadic Verb</title>
	<para>The Replicate dyadic verb is a verb of rank _ _ . It is applied to the whole of the right and left argument. There is no underlying verb.</para>
	<para>Replicate is used to replicate k-cells of the right argument. The result is a new noun with the replicated k-cells. The original noun is not modified.</para>
	<para>The left argument contains an integer vector of the same length as the first dimension of the right argument.</para>
		<para>The result contains the k-cells of the right argument, each replicated the number of times the corresponding left argument integer value shows. </para>
		<para>If the corresponding integer in the left argument is 0, the corresponding k-cell in the right argument will not be part of the result.</para>
		<para>Replicate can be used together with the dyadic Rank operator to replicate k-cells along other dimensions than the first dimension.</para>
<literallayout>Example:
<code>
    0 1 2 0 # 1 2 3 4
 2 3 3
    0 1 2 0 # '/ 1 1 / |i. 2 4
 1 2 2
 5 6 6   
</code></literallayout>
</section>
<section>
	<title>The Select Dyadic Verb</title>
	<para>The Select dyadic verb is a verb of rank _ _ . It is applied to the whole of the right and left argument. There is no underlying verb.</para>
	<para>Select is used to select k-cells of the right argument. The result is a new noun with the selected k-cells. The original noun is not modified.</para>
	<para>The left argument contains a boolean vector of the same length as the first dimension of the right argument.</para>
		<para>The result contains the k-cells of the right argument corresponding to true values in the left argument boolean vector. </para>
		<para>Select can be used together with the dyadic Rank operator to select k-cells along other dimensions than the first dimension.</para>
<literallayout>Example:
<code>
    false true true false /:: 1 2 3 4
 2 3
    false true true false /:: '/ 1 1 / |i. 2 4
 1 2
 5 6    
</code></literallayout>
</section>
<section>
	<title>The Shape Dyadic Verb</title>
	<para>The Shape dyadic verb is a verb of rank 1 _ . It is applied to the whole of the right and left argument. The dyadic Rank operator is used as a helper program to handle left arguments of rank higher than 1</para>
	<para>The Shape dyadic verb reshapes the k-cells of the right argument to the shape defined by the value of the vector left argument.</para>
	<para>The shape of the result is the shape of a k-cell appended to the value of the left argument.</para>
	<para>If the right argument does not contain any values there will be an error message.</para>
	<para>If the right argument contains fewer values than the result to be produced, values are taken like if there were an indefinite sequence of catenated right arguments to take from.</para>
<literallayout>Example:
<code>
    2 2 $ |i. 0
Length error
    2 2 $ 1 2 3 4
 1 2
 3 4  
    2 2 $ 1 2
 1 2
 1 2  
    2 2 $ |i. 2 2
Type: Integer, Shape: 2 2 2 , Values: 0 1 2 3 0 1 2 3
</code></literallayout>
</section>
<section>
	<title>The Take Dyadic Verb</title>
	<para>The Take dyadic verb is a verb of rank _ _ . It is applied to the whole of the right and left argument. There is no underlying verb.</para>
	<para>Take is used to take k-cells of the right argument. The result is a new noun of these k-cells. The original noun is not modified.</para>
	<para>If the left argument is a positive scalar, it denotes the number of k-cells that should be taken from the head of the right argument.</para>
	<para>If the left argument is a negative scalar, it denotes the number of k-cells that should be taken from the tail of the right argument.</para>	
	<para>If the left argument is a vector of length n, it denotes the number of k-cells that should be taken from the head or tail of the first n dimensions of the right argument.</para>
	<para>If the number of values to take is larger than the array length in the corresponding dimension, k-cells with <glossterm>fill values</glossterm> are added.</para>
	<para>The integer fill value is 0, the float fill value is 0.0, the boolean fill value is false, the unicode fill value is blank and the boxed array fill value is a scalar boxed array containing an empty integer vector.</para>
<literallayout>Example:
<code>
    2 &lt;.- 0 1 2 3
 0 1
    -2 &lt;.- 0 1 2 3
 2 3
    1 1 &lt;.- |i. 2 2 2
 0 1
    6 &lt;.- 0 1 2 3
 0 1 2 3 0 0
</code></literallayout>
</section>
<section>
	<title>The Transpose Dyadic Verb</title>
	<para>The Transpose dyadic verb is a verb of rank _ _ . It is applied to the whole of the right and left argument. There is no underlying verb.</para>
	<para>Transpose is used to transpose the array of the right argument. The result is a new noun with the transposed array. The original noun is not modified.</para>
	<para>The left argument is a vector of the same length as the rank of the right argument. The values of the left argument are the same as if they were used to index the shape of the right argument. If the rank of the right argument is three the left argument has to contain 0, 1 and 2.</para>
	<para>The result is that the dimensions change order to the order described by the left argument index.</para>
<literallayout>Example:
<code>
    |i. 2 3
 0 1 2
 3 4 5
    1 0 \:: |i. 2 3    
 0 3
 1 4
 2 5
</code></literallayout>
</section>
</section>
</section>
<section>
	<title>The JWithATwist Adverbs</title>
	<para>The adverbs are shown in the following table:</para>
		<table>
	<title>Adverbs</title>
	<tgroup cols="2">
		<tbody>
			<row>
				<entry><code>/</code></entry>
				<entry>The Fold adverb</entry>
			</row>			
			<row>
				<entry><code>|'</code></entry>
				<entry>The Monadic Rank adverb</entry>
			</row>		
			<row>
				<entry><code>'</code></entry>
				<entry>The Dyadic Rank adverb</entry>
			</row>
			<row>
				<entry><code>\</code></entry>
				<entry>The Scan adverb</entry>
			</row>	
		</tbody>
	</tgroup>
</table>	
<section>
	<title>The Fold Adverb</title>
	<para>The Fold adverb with its verb argument forms a verb of rank _ _ . It is applied to the whole of the right and left argument. There is no underlying verb.</para>
	<para>Fold applies the verb argument between an accumulator and successive k-cells of the right argument. The result is the accumulator value after the last verb application. The left value is the initial accumulator value.</para>
	<para>The accumulator and all verb application results must have the same shape and type. </para>
	<para>If the accumulator is boxed, it's contents can have any shape and type. </para>
<literallayout>Example:
<code>
    0 + / 1 2 3
 6    
</code></literallayout>
</section>
<section>
	<title>The Monadic Rank Adverb</title>
	<para>The monadic Rank adverb with its verb argument forms a verb of rank _ . It is applied to the whole of the right argument. There is no underlying verb.</para>
	<para>The monadic Rank adverb applies its verb to k-cells of the right argument, parts of the right argument with a certain rank.</para>
		<para>The monadic Rank adverb has a rank argument, evaluated during interpretation. The rank argument defines the k-cells of the verb application. If the rank argument is positive, it denotes the k-cell from the end of the shape of the argument. If the rank argument is negative, it denotes the k-cells from the beginning of the shape of the right argument. </para>
		<para>If we have an argument of shape 2 3 4 5 a rank of 1 would mean we operate on the shape 5 k-cells, a rank of -1 would mean we operate on the shape 3 4 5 k-cells.</para>
		<para>The part of the shape to the left of the part we operate on is called the outer shape.</para>
		<para>The verb application will result in a number of nouns, possibly of different shape.</para>
		<para>The Rank adverb will calculate the maximum length of these resulting nouns in each of their dimensions. The result is called the inner shape.</para>
		<para> The Rank adverb will reshape each of the produced results to the rank of the inner shape by adding ones to the left.</para>
		<para> The Rank adverb will then use the Take dyadic verb to create arrays with the shape of the inner shape from each of the produced results. In this process <glossterm>fill values</glossterm> are added. </para>
		<para>The Rank adverb will then put the maximized results in the parts of the result array defined by the outer shape.</para>
		<para>The result will have a shape defined by catenating the outer and the inner shape.</para>
<literallayout>Example:
<code>
    |&lt; |'/ 0 / 1 2 3
 1 2 3
    |$ |&lt; |'/ 0 / 1 2 3 
 3    	
    |&lt; |'/ 1 / 1 2 3
1 2 3
    |$ |&lt; |'/ 1 / 1 2 3	

    {! |&lt; 1 + ] } |'/ 0 / 1 2 3
 2 3 4
    |i. |'/ 1 / 2 2 $ 2 1 1 3
Type: Integer, Shape: 2 2 3 , Values: 0 0 0 1 0 0 0 1 2 0 0 0 ...
</code></literallayout>
<para>If we operate on an empty argument the monadic Rank adverb has special cases to handle. The argument  as a whole can be empty because the shape contains zeroes, but the part of the argument we operate on can be non-empty. If there is nothing to apply the verb to the shape and type of the result can not be determined by normal execution. It is still very important to handle these cases. What JWithATwist does is to create a <glossterm>fill value</glossterm> object or fill value objects of the same shape and type as the non-empty part of the argument. The verb is applied to the fill value object. The resulting shape and type is used as the inner shape and the result type. </para>
<para>If the application of the verb on the fill value objects cause an error, the program terminates with this error.</para>
<para>If the verb application on the fill value objects have results of the correct shape and type, and does not terminate with an error, the designed program using the Rank adverb will work for the special empty argument cases.  </para>
</section>
<section>
	<title>The Dyadic Rank Adverb</title>
	<para>The dyadic Rank adverb with its verb argument forms a verb of rank _ _ . It is applied to the whole of the right and left argument. There is no underlying verb.</para>
	<para>The dyadic Rank adverb applies its verb to k-cells of the left and right arguments, parts of the left and right arguments with a certain rank.</para>
		<para>The dyadic Rank adverb has a rank argument, evaluated during interpretation. The rank argument defines the k-cells of the verb application. If the rank argument is positive, it denotes the k-cell from the end of the shape of the argument. If the rank argument is negative, it denotes the k-cells from the beginning of the shape of the  argument. </para>
		<para>If we have an argument of shape 2 3 4 5 a rank of 1 would mean we operate on the shape 5 k-cells, a rank of -1 would mean we operate on the shape 3 4 5 k-cells.</para>
		<para>The part of the shape to the left of the part we operate on is called the outer shape.</para>
		<para>This outer shape must be the same for the left and right argument.</para>
		<para>The verb application will result in a number of nouns, possibly of different shape.</para>
		<para>The rank adverb will calculate the maximum length of these resulting nouns in each of their dimensions. The result is called the inner shape.</para>
		<para> The Rank adverb will reshape each of the produced results to the rank of the inner shape by adding ones to the left.</para>
		<para> The Rank adverb will then use the Take dyadic verb to create arrays with the shape of the inner shape from each of the produced results. In this process <glossterm>fill values</glossterm> are added. </para>
		<para>The Rank adverb will then put the maximized results in the parts of the result array defined by the outer shape.</para>
		<para>The result will have a shape defined by catenating the outer and the inner shape.</para>
<literallayout>Example:
<code>
    1 2 &lt;- '/ 1 1 / |i. 2 4
 1 2
 5 6
    10 20 {! |&lt; [ + ] }  '/ 1 1 / |i. 2 2
 10 21 12 23
    |$ 10 20 {! |&lt; [ + ] }  '/ 1 1 / |i. 2 2
 2    
    ( 2 2 $ 10 20 30 40 ) {! |&lt; [ + ] }  '/ 1 2 / |i. 2 2
 10 11 30 31
 22 23 42 43
    |$ ( 2 2 $ 10 20 30 40 ) {! |&lt; [ + ] }  '/ 1 2 / |i. 2 2	 
 2
     10 20 + |i. 2 2
 10 11
 22 23
</code></literallayout>
<para>If we operate on empty arguments the dyadic Rank adverb has special cases to handle. The argument or arguments as a whole can be empty because the shape contains zeroes, but the part of the argument we operate on can be non-empty. If there is nothing to apply the verb to the shape and type of the result can not be determined by normal execution. It is still very important to handle these cases. What JWithATwist does is to create a <glossterm>fill value</glossterm> object or fill value objects of the same shape and type as the non-empty parts of the argument or arguments. The verb is applied between one argument and the fill value object or between two fill value objects. The resulting shape and type is used as the inner shape and the result type. </para>
<para>If the application of the verb on the fill value objects cause an error, the program terminates with this error.</para>
<para>If the verb application on the fill value object or objects have results of the correct shape and type, and does not terminate with an error, the designed program using the Rank adverb will work for the special empty argument cases.  </para>
</section>
<section>
	<title>The Scan Adverb</title>
	<para>The Scan adverb with its verb argument forms a verb of rank _ _ . It is applied to the whole of the right and left argument. There is no underlying verb.</para>
	<para>Scan applies the verb argument between an accumulator and successive k-cells of the right argument. The result is an array of all accumulator values after the last verb application. The left value is the initial accumulator value.</para>
		<para>The accumulator and all verb application results must have the same shape and type. </para>
	<para>If the accumulator is boxed, it's contents can have any shape and type. </para>
<literallayout>Example:
<code>
    0 + \ 1 2 3
 1 2 6   
</code></literallayout>
</section>
</section>
<section>
	<title>The JWithATwist Conjunctions</title>
	<para>For the moment JWithATwist has no conjunctions and this section is empty. Many of the operations of the J conjunctions can be done in other ways in JWithATwist.</para>
</section>
	<section>
	<title>The JWithATwist Syntax</title>
<para>These simple or simplified verbs, adverbs and conjunctions are used to make this description easier to understand:</para>
<itemizedlist>
	<listitem>
		<para>Dyadic verb Addition,<code> +</code></para>
	</listitem>
	<listitem>
		<para>Dyadic verb Subtraction,<code> - </code></para>
	</listitem>
			<listitem>
		<para>Monadic verb Negation,<code> |- </code></para>
	</listitem>
	<listitem>
		<para>Monadic adverb,<code> / </code>. This operator is defined <code> u / y &lt;-&gt; y u y</code>. It applies the in-fix u verb between two copies of the argument.<code> + / 1 &lt;-&gt; 1 + 1 &lt;-&gt; 2</code>.</para>
	</listitem>
			<listitem>
		<para>Dyadic adverb,<code> /- </code>. This operator is defined <code>x u/- y &lt;-&gt; x u y</code>. It applies the infix u verb between the left and right argument.<code> 1 + /- 1 &lt;-&gt; 1 + 1 &lt;-&gt; 2</code></para>
	</listitem>
	<listitem>
		<para>Monadic conjunction,<code> |. </code>. This operator is defined<code> u |. v y &lt;-&gt; u y v y</code>. It applies the infix dyadic verb v between copies of the right argument and the monadic verb u to the result.<code> |- |. + 1 &lt;-&gt; |- 1 + 1 &lt;-&gt; -2 </code>.</para>
	</listitem>
			<listitem>
		<para>Dyadic conjunction,<code> . </code>. This operator is defined<code> x u . v y &lt;-&gt; u x v y </code>. It applies the infix dyadic verb v between the left and right arguments and the monadic verb u to the result.<code> 2 |- . + 5 &lt;-&gt; |- 2 + 5 &lt;-&gt; -7 </code>.</para>
	</listitem>
</itemizedlist>
<para>There is no order of precedence between the operations. Execution is from right to left modified by parenthesis.<code> |- |- |- 1 &lt;-&gt; -1</code></para>
<para>The language elements are associated to its arguments like this:</para>
<itemizedlist>
	<listitem>
		<para>A monadic verb has one noun argument to the right. Like this: <code>|- 1 </code>.</para>
	</listitem>
	<listitem><para>A dyadic verb has one noun argument to the left and one to the right. Like this:<code> 1 + 1 </code>.</para></listitem>
	<listitem><para>A monadic adverb has a verb argument to the left and a noun argument to the right. Like this:<code> + / 1 </code>.</para></listitem>
	<listitem><para>A dyadic adverb has a verb argument to the left, one noun argument to the left and one to the right. Like this:<code> 1 + /- 1 </code>.</para></listitem>
	<listitem><para>A monadic conjunction has a verb argument to the left and one to the right, and one noun argument to the right. Like this: <code>|- |. + 1 </code>.</para></listitem>
	<listitem><para>A dyadic conjunction has a verb argument to the left and one to the right, and one noun argument to the left and one to the right. Like this: <code>1 |- . + 1</code> .</para></listitem>
	<listitem><para>An adverb to the left of a conjunction is together with it&#39;s verb the left argument of the conjunction. Like this in the monadic case:<code> + / |. + 1 </code>. Like this in the dyadic case:<code> 1 + / . + 1 </code>.</para></listitem>
</itemizedlist>
<para>An adverb together with its left verb forms a new verb. A conjunction together with its right verb and its left verb or adverb forms a new verb.</para>
<para>Monadic verbs, adverbs and conjunctions create verb trains like this:</para>
<para><code> |-     + /     |-     |- |. +     |-     + / |. +     |- 1</code></para>
<para>I use extra blanks to show the separation between verbs.</para>
<para>You always need at least one blank between two syntax elements.</para>
<para>A program is called a <glossterm>noun definition</glossterm>. It is written between curly brackets, like this <code>{ some code }</code> . It can contain <glossterm>verb definitions</glossterm>, written between curly brackets where the first bracket is immediately followed by <code>!</code> . Like this <code>{! some code }</code> .</para>
<para>A verb definition can contain Left Noun and Right Noun, denoted by <code>[</code> and <code>]</code> . The Left Noun is a placeholder for the noun immediately preceding the verb definition. The Right Noun is a placeholder for the noun immediately following the verb definition.</para>
<para>A verb definition containing only Right Nouns forms a monadic verb. A verb definition containing a Left Noun forms a dyadic verb, even if there is no Right Noun. In that case you are forced to have a noun to the right of the verb definition and this noun is silently ignored.</para>
<para>This is a verb definition of a monadic increment verb<code> {! 1 + ] } </code>. Example of use: <code>{! 1 + ] } 2</code> .</para>
<para>This is a verb definition of a dyadic addition verb <code>{! [ + ] } </code>. Example of use: <code>1 {! [ + ] } 2</code> .</para>
<para>Left and Right nouns within brackets are placeholders for the noun arguments to the first verb definition enclosing the brackets. In this example the Left noun is one and the Right noun is two: <code>1 {! ( [ + ] ) + 1 } 2</code> .</para>
<para>There is no way to define adverbs and conjunctions in this version of JWithATwist.</para>
<literallayout>A sample session :
<code>
{ 1 }
 1
{ 1 + 1 }
 2
{ ( 1 - 1 ) + 1 }
 1
{ ( 1 - 1 ) {! [ + ] } 1 }
 1
{ { 1 - 1 } {! [ + ] } 1 }
 1
{ + / 1 }
 2
{ {! [ + ] } / 1 }
 2
{ + / |. + 1 }
 4
{ 2 + / . + 1 }
 6
{ 2 + / . + |- |- 1 }
 6
{ 2 + / . {! [ + ] } |- |- 1 }
 6
{ 2 + / . + |- {! |- ] } 1 }
 6
{ 2 + /- 3 }
 5
{ 5 {! ( [ + ] ) + [ + ] } 7 }
 24
{ |- + / |- |. + + / |. + |- 5 }
 -80</code></literallayout>
</section>
<section>
	<title>JWithATwist Use Cases</title>
	<para>JWithATwist can be used as a calculator in a terminal window with the included JWithATwist program. JWithATwist can also be used from F#. You can use the JWithATwist verbs, adverbs and conjunctions directly from F#, with no interpreter in between. You can define J verbs and use them as F# functions. You can use JWithATwist definitions as lambda expressions or unnamed variables and functions.</para>
	<para>JWithATwist can easily be extended. If you implement a new verb, adverb or conjunction as an F# function it can be included in the interpreter with only some minutes of work. You can also easily extend JWithATwist with verbs you define from JWithATwist expressions.</para>
	<para>The JWithATwist interpreter can be used separately. You can create your own language. The JWithATwist Mock Interpreter is a good starting point. If you want the basic APL/J syntax it is an easy way to create your own language.</para>
	<section>
	<title>The JWithATwist Terminal</title>
	<para>Install JWithATwist with the included Windows installation program. You will get a JWithATwist program in your Start menu. Run it and start writing JWithATwist expressions. Remember that all expressions are written within curly brackets. Also remember to put blanks between all language elements. If you press return without any input you will terminate the terminal session.</para>
	<para>If you cloned JWithATwist to your development environment you can start the terminal session by calling the Parser program.</para>
	<literallayout>Examples :
<code>
{ 1 }
 1
{ 1 + 1 }
 2
{ {! 1 + ] } |i. 3 }
 1 2 3
</code></literallayout>
</section>
<section>
	<title>Using JWithATwist From F#</title>
	<para>All JWithATwist verbs, adverbs and conjunctions can be used directly from F#. Usually the name is the same as the name of the language element preceded by J. JOpen, JBox, JAdd and JSubtract are some examples. Sometimes there is a monadic and a dyadic version of the language element. Then Monadic or Dyadic is appended to the name. JIotaMonadic, JIotaDyadic, JRankMonadic and JRankDyadic are some examples. </para>
	<para>When you use the verbs, adverbs and conjunctions you need noun arguments.</para>
	<para> A noun is a simple record structure containing type, shape and an F# array of values. You can see the type definitions at the top of the JWithATwist.Base module. You can easily create a noun from F# variables.</para>
	<para>If you want to create a noun from a JWithATwist expression you can use the JNounDefine helper function. It takes a string right argument with a JWithATwist expression and returns a noun.</para>
	<para>If you want to use a resulting noun in F# you have to use the record structure. There is no helper function to create any special F# representation from a noun.</para>
	<para>You can also create F# functions from JWithATwist expressions. There are two helper functions, JVerbMonadicDefine and JVerbDyadicDefine. They take a string right argument with a JWithATwist expression and return a monadic or dyadic verb. </para>
	<para>Sometimes you want to create a verb directly in F# from other verbs. You can just create a function with one or two noun arguments and use these in the function definition.</para>
	<para>You can also partially execute verbs, adverbs and conjunctions in F#, and create new verbs, adverbs or conjunctions as a result.</para>
	<para>If you define the JWithATwist verbs at the module level, they will only be interpreted once, when the module is loaded. After definition JWithATwist verbs are a composition of compiled code. There is no  interpretation when the resulting F# function is executed.</para>
		<literallayout>Examples :
<code>
    JPrint (JIotaMonadic (JNounDefine @"{ 3 }"))
 0 1 2
    let Increment = JVerbMonadicDefine @"{! 1 + ] }"
    JPrint (Increment (JIotaMonadic (JNounDefine @"{ 3 }")))
 1 2 3	
    let Add = JVerbDyadicDefine @"{! [ + ] }" 
    JPrint (Add (JNounDefine @"{ 1 }") (JNounDefine @"{ 1 }"))
 2
    let Increment = Add (JNounDefine @"{ 1 }")
    JPrint (Increment (JIotaMonadic (JNounDefine @"{ 3 }")))
 1 2 3	
    let aNoun = JNounDefine @"{ 1 }"
    let f aNoun =
        match aNoun.JType,aNoun.JShape,aNoun.JValue with
        |aType,aShape,JTypeIntegerArray aValue ->
            printfn "%i" aValue.[0]  
        |_->
            raise JExceptionSystemError
    f aNoun
1
</code></literallayout>
<para>The printout in the examples is what is written to standard output as a result of the preceding code sample.</para>
</section>
<section>
	<title>Extending JWithATwist</title>
	<para>To extend JWithATwist with new verbs, adverbs and conjunctions you first have to create the F# function. If you want you can use JWithATwist code in the definition. You can also use parsed JWithATwist expressions.</para>
	<para>The extension is done in the ParserInterface module. You copy and modify the code for some similar language element. You just have to change some lines of code. Then you have to insert the new parsing code in the parser, by modifying parseVerbAdverbConjunction. All is very easy.
	</para>
</section>
<section>
	<title>Using the JWithATwist Mock Interpreter to Create Your Own Language</title>
	<para>If you want to create your own language and use the JWithATwist interpreter, you just copy the ParserMockDefinitions, ParserMockInterface and ParserMock files into your F# project. If you want you can copy the test code in JWithATwist.Test.ParserMock. Run the Parser program in ParserMock and try the JWithATwist Mock Interpreter. Then you can change it by modifying the definitions in ParserMockDefinitions and the code in ParserMockInterface. You normally don't have to change the interpreter and the parse code in ParserMock. It is easy. Creating the language elements can be difficult, of course.</para>
</section>
</section>
	<glossary>
	<title>Glossary</title>
		<glossentry xml:id="glossary.adverb">
		<glossterm>Adverb</glossterm>
		<glossdef><para>A function with a verb argument and one or two noun arguments, returning a noun.</para></glossdef>
	</glossentry>
		<glossentry xml:id="glossary.agreement">
		<glossterm>Agreement</glossterm>
		<glossdef><para>How JWithATwist allows operations between arguments of different shape.</para></glossdef>
	</glossentry>	
		<glossentry xml:id="glossary.boxed">
		<glossterm>Boxed</glossterm>
		<glossdef><para>A noun of data type boxed contains other nouns. It is an n-dimensional array of n-dimensional arrays.</para></glossdef>
	</glossentry>	
		<glossentry xml:id="glossary.cell">
		<glossterm>Cell</glossterm>
		<glossdef><para>The smallest unit in an n-dimensional array. A simple data type or another noun.</para></glossdef>
	</glossentry>	
		<glossentry xml:id="glossary.conjunction">
		<glossterm>Conjunction</glossterm>
		<glossdef><para>A function with two verb arguments and one or two noun arguments, returning a noun.</para></glossdef>
	</glossentry>	
		<glossentry xml:id="glossary.dyadic">
		<glossterm>Dyadic</glossterm>
		<glossdef><para>A verb, adverb or conjunction with two noun arguments.</para></glossdef>
	</glossentry>	
		<glossentry xml:id="glossary.fillvalue">
		<glossterm>Fill value</glossterm>
		<glossdef><para>Fill values can be used when a noun is resized. The integer fill value is 0, the float fill value is 0.0, the boolean fill value is false, the unicode fill value is blank and the boxed array fill value is a scalar boxed array containing an empty integer vector.</para></glossdef>
	</glossentry>		
	
		<glossentry xml:id="glossary.kcell">
		<glossterm>K-cell</glossterm>
		<glossdef><para>The noun is seen as a structure of k-cells. The scalar is a 0-cell, the vector a 1-cell, the table a 2-cell and so on for higher dimensions.</para></glossdef>
	</glossentry>		
		<glossentry xml:id="glossary.monadic">
		<glossterm>Monadic</glossterm>
		<glossdef><para>A verb, adverb or conjunction with one noun argument.</para></glossdef>
		</glossentry>	
	<glossentry xml:id="glossary.noun">
		<glossterm>Noun</glossterm>
		<glossdef><para>An n-dimensional array of values where the values are simple data types or other n-dimensional arrays.</para></glossdef>
	</glossentry>	
		<glossentry xml:id="glossary.noundefinition">
		<glossterm>Noun definition</glossterm>
		<glossdef><para>A noun definition is written between curly brackets. It contains a noun or an expression returning a noun.</para></glossdef>
	</glossentry>	
			<glossentry xml:id="glossary.rank">
		<glossterm>Rank</glossterm>
		<glossdef><para>The rank of a noun is the number of dimensions of the array it contains. The rank of a verb is the size of k-cell or k-cells of the argument or arguments that the actual underlying verb operation is performed on.</para></glossdef>
	</glossentry>
	<glossentry xml:id="glossary.scalar">
		<glossterm>Scalar</glossterm>
		<glossdef><para>A noun with zero dimensions contains only one value. It is called a scalar. An operation on 0-cells  is called a scalar operation.</para></glossdef>
	</glossentry>	
	<glossentry xml:id="glossary.verb">
		<glossterm>Verb</glossterm>
		<glossdef><para>A function with one or two noun arguments returning a noun.</para></glossdef>
	</glossentry>
			<glossentry xml:id="glossary.verbdefinition">
		<glossterm>Verb definition</glossterm>
		<glossdef><para>A verb definition is written between curly brackets with the opening bracket followed by <code>!</code> . It an expression returning a verb.</para></glossdef>
	</glossentry>		
</glossary>
</article>
